ğŸ§  Final Backend Stack (Locked ğŸ”’)

Node.js

Express.js

MongoDB (Mongoose)

Redis

BullMQ (Queue)

JWT + OTP

TypeScript

Docker-ready



ğŸ“ Backend Folder Structure (REAL WORLD)

Create backend/ folder outside frontend.



backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ app.ts
â”‚   â”œâ”€â”€ server.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”œâ”€â”€ env.ts
â”‚   â”‚   â”œâ”€â”€ mongo.ts
â”‚   â”‚   â””â”€â”€ redis.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”œâ”€â”€ auth.routes.ts
â”‚   â”‚   â”œâ”€â”€ product.routes.ts
â”‚   â”‚   â”œâ”€â”€ cart.routes.ts
â”‚   â”‚   â””â”€â”€ order.routes.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”œâ”€â”€ auth.controller.ts
â”‚   â”‚   â”œâ”€â”€ product.controller.ts
â”‚   â”‚   â”œâ”€â”€ cart.controller.ts
â”‚   â”‚   â””â”€â”€ order.controller.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ auth.service.ts
â”‚   â”‚   â”œâ”€â”€ product.service.ts
â”‚   â”‚   â”œâ”€â”€ cart.service.ts
â”‚   â”‚   â””â”€â”€ order.service.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ user.model.ts
â”‚   â”‚   â”œâ”€â”€ product.model.ts
â”‚   â”‚   â””â”€â”€ order.model.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ middlewares/
â”‚   â”‚   â”œâ”€â”€ auth.middleware.ts
â”‚   â”‚   â””â”€â”€ error.middleware.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ queues/
â”‚   â”‚   â”œâ”€â”€ otp.queue.ts
â”‚   â”‚   â”œâ”€â”€ order.queue.ts
â”‚   â”‚   â””â”€â”€ workers/
â”‚   â”‚       â”œâ”€â”€ otp.worker.ts
â”‚   â”‚       â””â”€â”€ order.worker.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ jwt.ts
â”‚   â”‚   â””â”€â”€ logger.ts
â”‚   â”‚
â”‚   â””â”€â”€ types/
â”‚       â””â”€â”€ express.d.ts
â”‚
â”œâ”€â”€ .env
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ tsconfig.json
â””â”€â”€ package.json




Express App Flow (Samajh le ye important hai)

Request
  â†“
Route
  â†“
Controller (thin)
  â†“
Service (logic)
  â†“
DB / Redis / Queue



ğŸ§± Step-by-Step Backend Blueprint
âœ… STEP 1: Backend Init


mkdir backend && cd backend

npm init -y && \
npm install express mongoose cors dotenv jsonwebtoken bcrypt bullmq ioredis && \
npm install -D typescript ts-node nodemon @types/node @types/express && \
npx tsc --init && \
mkdir -p src/{config,routes,controllers,services,models,middlewares,queues/workers,utils,types} && \
touch src/{app.ts,server.ts} && \
touch src/config/{env.ts,mongo.ts,redis.ts} && \
touch src/routes/{auth.routes.ts,product.routes.ts,cart.routes.ts,order.routes.ts} && \
touch src/controllers/{auth.controller.ts,product.controller.ts,cart.controller.ts,order.controller.ts} && \
touch src/services/{auth.service.ts,product.service.ts,cart.service.ts,order.service.ts} && \
touch src/models/{user.model.ts,product.model.ts,order.model.ts} && \
touch src/middlewares/{auth.middleware.ts,error.middleware.ts} && \
touch src/queues/{otp.queue.ts,order.queue.ts} && \
touch src/queues/workers/{otp.worker.ts,order.worker.ts} && \
touch src/utils/{jwt.ts,logger.ts} && \
touch src/types/express.d.ts && \
touch .env docker-compose.yml




âœ… STEP 2: Basic Server

src/app.ts


import express from "express";
import cors from "cors";

const app = express();

app.use(cors());
app.use(express.json());

export default app;



src/server.ts


import app from "./app";

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`Backend running on port ${PORT}`);
});



ğŸ” STEP 3: Auth + OTP (Queue based)

API Mapping (tera frontend)
Screen	API
login.tsx	POST /auth/send-otp
otp.tsx	POST /auth/verify-otp
Flow

send-otp
  â†’ push job to OTP queue
  â†’ worker sends SMS


ğŸ“¨ STEP 4: BullMQ Setup (VERY IMPORTANT)
src/config/redis.ts


import { Redis } from "ioredis";

export const redis = new Redis({
  host: "localhost",
  port: 6379,
});



src/queues/otp.queue.ts

import { Queue } from "bullmq";
import { redis } from "../config/redis";

export const otpQueue = new Queue("otp-queue", {
  connection: redis,
});



src/queues/workers/otp.worker.ts

import { Worker } from "bullmq";
import { redis } from "../../config/redis";

new Worker(
  "otp-queue",
  async job => {
    console.log("Sending OTP:", job.data);
  },
  { connection: redis }
);



ğŸ›’ STEP 5: Cart (Redis Based)

Cart DB me mat daal, Redis use kar:

cart:userId â†’ [{ productId, qty }]


Fast & scalable.



ğŸ“¦ STEP 6: Orders (Queue Heavy)
Order create flow


POST /orders
 â†“
Save order in DB
 â†“
Push job to order queue
 â†“
Worker:
   - reduce inventory
   - notify delivery



ğŸ—„ï¸ STEP 7: Prisma DB Schema (Basic)
prisma/schema.prisma


model User {
  id        String   @id @default(uuid())
  phone     String   @unique
  name      String?
  orders    Order[]
}

model Product {
  id       String  @id @default(uuid())
  name     String
  price    Int
  stock    Int
}

model Order {
  id        String   @id @default(uuid())
  userId    String
  status    String
  total     Int
  user      User     @relation(fields: [userId], references: [id])
}



ğŸ” STEP 8: JWT Auth Middleware

export const auth = (req, res, next) => {
  const token = req.headers.authorization?.split(" ")[1];
  if (!token) return res.sendStatus(401);
  next();
};





Phase 1 âœ… Server + DB (DONE)
Phase 2 ğŸ” Auth (User + JWT)
Phase 3 ğŸ“¦ Product APIs
Phase 4 ğŸ›’ Cart APIs
Phase 5 ğŸ“¬ Order + Queue (BullMQ)
Phase 6 ğŸ§ª Testing
Phase 7 ğŸš€ Production Docker








